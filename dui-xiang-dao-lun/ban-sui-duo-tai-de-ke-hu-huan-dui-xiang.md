# 伴随多态的可互换对象

在处理类型的层次结构时 , 常把一个对象不当做它所属的特定类型来对待 , 而是将其当做其基类的对象来对待 . 可以编写出不依赖于特定类型的代码 . 

通过导出新的子类型而轻松扩展设计的能力是对改动进行封装的基本方式之一 . 但是 , 在试图将导出类型的对象当作其泛化基类型对象来看待时 , 存在一个问题 . 编译器无法精确的了解哪一段代码将会被执行 , 也就是说编译器不可能产生传统意义上的函数调用 . 一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定 , 也就是说调用解析到将要被执行的代码的绝对地址 . 在OOP中 , 程序直到运行时才能确定代码的地址 , 所以消息发送到一个泛化对象时 , 必须采用其他的机制 . 

为了解决这个问题 , 面向对象程序设计语言使用了**后期绑定**的概念 . 当向对象发送消息时 , 被调用的代码直到运行时才能确定 . 编译器确保被调用方法的存在 , 并对调用参数和返回值执行类型检查\(无法提供此类保证的就是弱类型语言\) , 但是并不知道将被执行的确切代码 . 

在某些语言中 , 必须明确的声明希望某个方法具备后期绑定属性所带来的灵活性 , 比如CPP是使用virtual关键字来实现的 . 这些语言中方法的默认情况不是动态绑定的 , 而在java中 , 动态绑定是默认行为 , 不需要添加额外的关键字来实现多态 . 

