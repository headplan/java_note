# 继承

以现有的类为基础 , 复制它 , 然后通过添加和修改这个副本来创建新的类 . 当源类发生变动时 , 被修改的副本也会反映出这些变动 .

类型不仅仅只是描述了作用于一个对象集合上的约束条件 , 同时还有与其他类型之间的关系 . 两个类型可以有相同的特性和行为 , 但是其中一个类型可能比另一个含有更多的特性 , 并且可以处理更多的消息 , 或以不同的方式来处理消息 . 继承使用基类和导出类的概念表示了这种类型之间的相似性 .

一个基类包含其所有导出类所共享的特性和行为 . 可以创建一个基类来表示系统中某些对象的核心概念 , 从基类中导出其他类型 , 来表示此核心可以被实现的各种不同方式 .

当继承现有类型时 , 也就是创造了新的类型 . 这个心的类型不仅包括现有类型的所有成员 , 而且更重要的是复制了基类的接口 . 也就是说 , 所有可以发送给基类对象的消息同时也可以发送给导出类对象 . 由于通过发送给类的消息的类型是可知类型 , 所以这就意味着导出类与基类具有相同的类型 .

由于基类和导出类具有相同的基础接口 , 所以伴随此接口的必定有某些具体实现 . 也就是说 , 当对象接收到特定消息时 , 必须有某些代码去执行 . 如果只是简单的继承一个类而并不做其他任何事 , 那么在基类接口中的方法将会直接继承到导类中 . 也就是说导出类的对象不仅与基类拥有相同的类型 , 而且还拥有相同的行为 .

使基类和导出类产生差异 , 第一种就是直接在导出类中添加新方法 . 第二种就是覆盖基类的方法 , 也就是Overrriding那个方法 .

要想覆盖某个方法 , 可以直接在导出类中创建该方法的新定义即可 .

#### 是一个与像是一个的关系

**is-a关系**

继承只覆盖基类方法 , 就意味着导出类和基类是完全相同的类型 , 因为它们具有完全相同的接口 . 结果可以用一个导出类对象来完全替代一个基类对象 , 这可以被视为纯粹替代 , 通常称之为替代原则 . 

**is-like-a关系**

在导出类型中添加新的接口元素 , 新的类型仍然可以替代基类 , 但是基类无法访问新的方法 . 这种情况可以描述为is-like-a的关系 . 新类型具有旧类型的接口 , 同时还包含其他方法 , 所以说他们不完全相同 . 

is-a和is-like-a两种关系在合适的场景中应用 . 





