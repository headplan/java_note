# 容器

通常来说 , 如果不知道在解决某个特定问题时需要多少个对象 , 或者它们将存货多久 , 那么就不可能知道如何存储这些对象 . 对于面向对象设计中的大多数问题而言 , 解决方案似乎有些轻率 , 就是创建另一个中对象类型 . 这种新的对象类型是对其他对象的引用 . 当然 , 可以在大多数语言中都有的数组类型来实现相同的功能 . 但这个通常被称为容器的新对象 , 在任何需要时都可以扩充自己以容纳你至于其中的所有东西 . 因此不需要知道将来会把多少个对象至于容器中 , 都是在容器对象中处理所有细节 .

好的OOP语言都有一组容器 , 它们作为开发包的一部分 . 比如CPP中 , 容器是标准CPP类库的一部分 , 经常被称为标准模板类库 . Java在其标准类库中也包含大量的容器 , 具有满足不同需要的各种类型的容器 , 比如List\(用于存储序列\) , Map\(也被称为关联数组 , 用来建立对象之间的关联\) , Set\(每种对象类型只持有一个\) , 以及诸如队列 , 树 , 堆栈等更多的构件 .

从设计的观点来看 , 真正需要的只是一个可以被操作 , 从而解决问题的序列 . 如果单一类型的容器可以满足所有需要 , 那么设计不同种类的序列就没必要了 , 然后还是需要对容器有所选择 . 不同容器提供了不同类型的接口和外部行为 . 不同的容器对于某些操作也具有不同的效果 . 比如 , ArrayList和LinkedList , 他们具有相同的接口和外部行为的序列 , 在ArrayList中 , 随机访问元素是一个话费固定时间的操作 , 但在LinkedList来说 , 随机取元素需要在列表中移动 , 这种代价是相当高的 .

#### 参数化类型

在JavaSE5之前 , 容器存储的对象都只具有Java中的通用类型 , 也就是Object . 单根继承结构意味着 , 所有东西都是Object类型 , 所有可以存储Object的容器可以存储任何东西 . 这样容器更容易复用 .

要使用这样的容器 , 只需在其中置入对象引用 , 稍后还可以将它们取回 . 但是由于容器只存储Object , 所以当将对象引用置入容器时 , 它必须被向上转为Object , 身份也会丢失 . 当把它取回时 , 就获取了一个对Object对象的引用 , 而不是对置入时的那个类型的对象的引用 . 怎么变回先前置入容器中具有的使用接口的对象呢 ?

这里再次用到了转型 , 这一次不是向继承结构的上层转型为一个更泛化的类型 , 而是向下转型为更具体的类型 , 向上转型是安全的 , 比如Circle是一个Shape类型 , 但是不知道Object是Circle还是Shape .

所以 , 向下转型是危险的 , 但是可以用异常来捕获 . 尽管如此 , 当从容器中取出对象引用时 , 还是必须要以某种方式记住这些对象究竟是什么类型 , 这样才能执行正确的向下转型 .

向下转型和运行时的检查需要额外的程序运行时间 , 那么创建这样的容器 , 它知道自己所保存的对象的类型 , 从而不需要向下转型以及消除来了犯错误的可能 , 这种解决方案就叫做**参数化机制** . 参数化类型就是一个编译器可以自动定制作用于特定类型上的类 . 比如 , 通过使用参数化类型 , 编译器可以定制一个只接纳和取出Shape对象的容器 .

JavaSE5重大的变化之一就是增加了参数化类型 , 在Java中称为泛型 , 一对尖括号 , 中间包含类型信息 , 通过这些特征就可以识别对泛型的使用 .

```java
ArrayList<Shape> shapes = new ArrayList<Shape>();
```



