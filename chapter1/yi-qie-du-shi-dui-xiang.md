# 一切都是对象

尽管Java是基于CPP的 , 但是相比之下 , Java是一种更纯粹的面向对象程序设计语言 .

#### 用引用操纵对象

每种编程语言都有自己的操纵内存中元素的方式 . 有时候 , 必须注意将要处理的数据是什么类型 . 是直接操纵元素 , 还是用某种基于特殊语法的间接表示 .

Java里都会简化 . 一切都被视为对象 , 因此可以采用单一固定的语法 . 尽管如此 , 但操纵的标识符实际上是对象的一个引用 . 可以将这一情形想象成用遥控器来操纵电视 .

即使没有电视 , 遥控器也可以独立存在 . 也就是说有引用 , 并不一定需要有一个对象与它关联 . 因此 , 如果想操纵一个词或句子 , 则可以创建一个String引用 .

```
String s;
```

但这里所创建的只是引用 , 并不是对象 . 如果此时向s发送一个消息 , 就会返回一个运行时错误 . 这是因为此时s实际上没有与任何事物相关联 . 因此 , 一种安全的做法是 : 创建一个引用的同时便进行初始化 .

```
String s = "asdf";
```

这里是Java的特性 , 字符串可以用带引号的文本初始化 . 通常 , 必须对对象采用一种更通用的初始化方法 .

#### 必须由你创建所有对象

一旦创建了一个引用 , 就希望它能与一个新的对象相关联 . 通常用new操作符来实现这一目的 . new关键字的意思是 : 给我一个新对象 . 所以前面的例子可以写成 :

```
String s = new String("asdf");
```

它不仅表示 , 给我一个新的字符串 , 通过初始化字符串 , 给出了怎样产生这个String的信息 . 除了String类型 , Java提供了大量过剩的现成类型 , 还可以自行创建类型 .

**存储到什么地方**

对象放置安排的五个不同地方 :

* **寄存器** - 这是最快的存储区 , 位于处理器内部 . 寄存器数量有限 , 所以按需分配 . 不能直接控制 , 程序中也感觉不到 , 但C/CPP可以想编译器建议寄存器的分配方式 . 
* **堆栈** - 通用RAM , 仅次于寄存器 . Java系统必须知道堆栈内所有项的确切声明周期 , 以便上下移动堆栈指针 , 分配内存 , 当然也限制了一部分灵活性 , 所以某些Java数据存储于堆栈中 , 特别是对象引用 , 但是Java对象并不存储于其中 . 
* **堆** - 一种通用的内存池\(也位于RAM区\) , 用于存放所有的Java对象 . 堆的好处是 , 编译器不需要知道存储的数据在堆里存活多长时间 . 因此 , 在堆里分配存储有很大的灵活性 . 需要一个对象 , 只需要new一下 , 执行代码时 , 会自动在堆里进行存储分配 . 当然 , 代价是进行存储分配时需要更多的时间 . 
* **常量存储** - 常量值通常直接存放在程序代码内部 , 这样做是安全的 , 因为它们永远不会被改变 . 有时 , 在嵌入式系统中 , 常量本身会和其他部分隔离开 , 所以在这种情况下 , 可以选择将其存放在ROM\(只读存储器\)中 . 
* **非RAM存储** - 如果数据完全存活于程序之外 , 那么它可以不受程序的任何控制 , 在程序没有运行时也可以存在 . 其中两个基本的例子是流对象和持久化对象 . 在流对象中 , 对象转化成字节流 , 通常被发送给另一台机器 . 在持久化对象中 , 对象被存放于磁盘上 , 因此 , 即使程序终止 , 它仍可以保持自己的状态 . 
  这种存储方式的技巧在于 : 把对象转化成可以存放在其他媒介上的事务 , 在需要时 , 可以恢复成常规的 , 基于RAM的对象 . Java提供了轻量级持久化的支持 ,  比如JDBC和Hibernate这样的机制提供了更加复杂的在数据库中存储和读取对象信息的支持 .  

##### 基本类型

程序中的特殊类型 , 可以理解为基本类型 . new将对象存储在堆里 . Java中 , 不用new来创建变量 , 而是创建一个并非是引用的"自动"变量 . 这个变量直接存储值 , 并置于堆栈中 , 更加的高效 .

Java要切丁每种基本类型所占存储空间的大小 . 其不变性是Java比其他大多数语言更具可移植性 .

![](/assets/javajibenleixing.png)

* 所有数值类型都有正负号 . 
* boolean类型所占存储空间的大小没有明确指定 , 仅定义为能够取字面值true或false . 
* 基本类型具有的包装器类 , 可以在堆中创建一个非基本对象 , 用来表示对应的基本类型 . 

```
char c = 'x';
Character ch = new Character(c);
Character ch = new Character('x');
```

JavaSE5的自动包装功能将自动的将基本类型转换为包装器类型 :

Character ch = 'x';

并可以反向转换 :

char c = ch;

**高精度数字**

Java提供了两个用于高精度计算的类 : BigInteger和BigDecimal . 虽然它们大体上属于包装器类的范畴 , 但二者都没有对应的基本类型 . 不过这两个类包含的方法 , 提供的操作与对基本类型执行的操作类似 , 也就是说能够作用与int或float的操作 , 也同样能够作用与BigInterger或BigDecimal . 只是调用的是方法 , 不是运算符 , 所以速度稍慢 .

**BigInteger**支持任意精度的整数 , 可以理解为在运算中支持任何大小的整数值 , 不会丢失任何信息 .

**BigDecimal**支持任何精度的浮点数 . 例如精确的货币计算 .

**Java中的数组**

几乎所有语言都支持数组 , 在C和CPP中使用数组很危险 , 因为他们就是内存块 . Java的主要目标之一是安全性 , 确保数组会被初始化 , 而且不能在它的范围之外被访问 .

当创建一个数组对象时 , 实际上就是创建了一个引用数组 , 并且每个引用都会自动被初始化为一个特定值 , 该值拥有自己的关键字 null . Java中的null , 可以理解为这个引用还没有指向某个对象 . 在使用任何引用前 , 必须为其制定一个对象 . 使用一个还是null的引用 , 运行时会报错 . 因此 , 常犯的数组错误在Java中就可以避免 .

还可以创建用来存放基本数据类型的数组 , 比那一起也能确保数组初始化 , 因为它会将这种数组所占有的内存全部置零 .

#### 永远不需要销毁对象

变量的生命周期概念 .

**作用域**

大多数过程化语言都有作用域的概念 . 作用域决定了在其内定义的变量名的可见性和生命周期 . 在C , CPP和Java中 , 作用域由花括号的位置决定 .

```
{
    int x = 12;
    // Only x available
    {
        int q = 96;
    }
}
```

在作用域里定义的变量只可用于作用域结束之前 . // 表示注释 . 空格 , 制表符 , 换行都不会影响程序的执行结果 .

在Java中 :

```
{
    int x = 12;
    {
        int x = 96;
    }
}
```

编译器会报错 , 因为变量x已经定义 .

**对象的作用域**

Java对象不具备和基本类型一样的生命周期 . 当用new创建一个Java对象时 , 它可以存活于作用域之外 . 假设 :

```
{
    String s = new String("a string");
}
```

引用s在作用域终点就消失了 . 然而 , s指向的String对象仍继续占据内存空间 . 在上面的代码中 , 无法在这个作用域之后访问这个对象 , 因为对它唯一的引用已经超出了作用域的范围 .

在Java中 , 由new创建的对象 , 只要需要就会一直保留下去 , 而且Java的垃圾回收机制 , 会监视用new创建的所有对象 , 并辨别不会再被引用的对象 . 随后释放这些对象的内存空间 . 这样就消除了这类内存泄漏问题 .

#### 创建新的数据类型 : 类

```
class ATypeName {}
```

现在就可以用new来创建这种类型的对象 :

```
ATypeName a = new ATypeName();
```

**字段和方法**

一旦定义了一个类 , 就可以在类中设置两种类型的元素 , 字段和方法 . 字段可以是任何类型的对象 , 可以通过其引用与其进行通信 ; 也可以是基本类型中的一种 . 如果字段是对某个对象的引用 , 那么必须初始化该引用 , 必须new一个实际的对象 .

```
class DataOnly {
    int i;
    double d;
    boolean b;
}
DataOnly data = new DataOnly();
```

可以给字段赋值 , 但首先必须知道如何引用一个对象的成员 . 具体的实现为 : 在对象引用的名称之后紧接着一个句点 , 然后再接着是对象内部的成员名称 :

```
objectReference.member
data.i = 47;
data.d = 1.1;
data.b = false;
// 还可以继续使用.
myPlane.leftTank.canpacity = 100;
```

**基本成员默认值**

若类的某个成员是基本数据类型 , 即使没有进行初始化 , Java也会确保它获得一个默认值 :

![](/assets/morenzhi.png)

但最好是明确的对变量进行初始化 . 在局部变量中 , 如果在某个方法中定义 :

```
int x;
```

那么变量x得到的可能是任意值 , 而不会自动初始化为0 . 所以在使用x前 , 应该先对其赋值一个适当的值 .

#### 方法 , 参数和返回值

Java中用方法这个术语来表示做某些事情的方式 , 把它看作是函数也无妨 . Java的方法决定了一个对象能够接受什么样的消息 . 方法的基本组成部分包括 : 名称 , 参数 , 返回值和方法体 .

```java
ReturnType methodName(/* Argument list */) {
    /* Method body */
}
```

返回类型描述的是在调用方法之后从方法返回的值 . 参数列表给出了要传给方法的信息的类型和名称 . 方法名和参数列表合起来称为方法签名 , 唯一的标识出某个方法 .

Java中的方法只能作为类的一部分来创建 . 方法只有通过对象才能被调用 , 且这个对象必须能执行这个方法调用 .

对象调用方法的行为通常被称为发送消息给对象 . 面向对象的程序设计通常简单的归纳为向对象发送消息 .

**参数列表**

方法的参数列表指定要传递给方法什么样的信息 . 参数类型也必须是正确的 .

例如 :

```
int storage(String s) {
    return s.length() * 2;
}
```

这里的return关键字表示已经做完 , 离开此方法 . 这个值要放在return语句后面 . 可以定义方法返回任意想要的类型 , 不想返回任何值 , 可以指示此方法返回void\(空\) .

```
boolean flag() { return true; }
double naturalLogBase() { return 2.718; }
void nothing() { return; }
void nothing2() {}
```

如果返回类型是void , return关键字的作用只是用来退出方法 .

#### 构建一个Java程序

#### 第一个Java程序

#### 注释和嵌入式文档

```
/* 多行注释 */
// 单行注释
```

#### 编码风格



